#!/bin/bash
set -euo pipefail

KEY_FILE="$HOME/.llm_api_keys.json"

show_help() {
  cat <<EOF
Usage: gcommit [options]

Generate a concise commit message using Gemini based on git changes.

Options:
  -a, --all         Use all changes (staged + unstaged)
  -n, --no-commit   Only show and copy the message (no commit)
  -h, --help        Show this help message

Examples:
  gcommit            Generate message from staged changes only
  gcommit -a         Generate message from all changes
  gcommit -n         Generate message and copy to clipboard
  gcommit -a -n      Use all changes, show message, copy to clipboard
EOF
}

# --- Parse arguments ---
MODE="staged"
NO_COMMIT=false

for arg in "$@"; do
  case "$arg" in
    -a|--all)
      MODE="all"
      ;;
    -n|--no-commit)
      NO_COMMIT=true
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      echo "‚ùå Unknown option: $arg"
      echo "Run 'gcommit --help' for usage information."
      exit 1
      ;;
  esac
done

# --- Validate API key file ---
if [ ! -f "$HOME/.llm_api_keys.json" ]; then
  echo "‚ùå Error: Missing API key file at $HOME/.llm_api_keys.json"
  exit 1
fi

API_KEY=$(jq -r '.providers.gemini.api_key // empty' "$HOME/.llm_api_keys.json")
if [ -z "$API_KEY" ]; then
  echo "‚ùå Error: Gemini API key not found in $HOME/.llm_api_keys.json"
  exit 1
fi

export GEMINI_API_KEY="$API_KEY"

# --- Check for changes ---
if git diff --cached --quiet && git diff --quiet; then
  echo "‚ö†Ô∏è  No changes to analyze (working directory clean)."
  exit 0
fi

# --- Gather repo info ---
STAGED_FILES=$(git diff --cached --name-only || true)
UNSTAGED_FILES=$(git diff --name-only || true)
UNTRACKED_FILES=$(git ls-files --others --exclude-standard || true)

# --- Detect files that are both staged and modified ---
BOTH_STAGED_AND_MODIFIED=$(comm -12 \
  <(echo "$STAGED_FILES" | sort) \
  <(echo "$UNSTAGED_FILES" | sort) || true)

# --- Report summary ---
echo ""
echo "üìã Commit report (context)"
echo "--------------------------------------------------"
if [ -n "$STAGED_FILES" ]; then
  echo "üóÇÔ∏è  Staged files:"
  echo "$STAGED_FILES"
else
  echo "üóÇÔ∏è  Staged files: (none)"
fi
echo ""
echo "üìÇ Not included in commit (modified but unstaged):"
echo "${UNSTAGED_FILES:-"(none)"}"
echo ""
echo "üìÑ Untracked files:"
echo "${UNTRACKED_FILES:-"(none)"}"
echo "--------------------------------------------------"

# --- Show warning if any file is both staged and modified ---
if [ -n "$BOTH_STAGED_AND_MODIFIED" ]; then
  YELLOW="\033[1;33m"
  RESET="\033[0m"
  echo ""
  echo -e "${YELLOW}‚ö†Ô∏è  WARNING: Some files are both staged and modified (not fully committed):${RESET}"
  echo -e "${YELLOW}$BOTH_STAGED_AND_MODIFIED${RESET}"
  echo -e "${YELLOW}üëâ Consider re-staging them (e.g. 'git add <file>') to ensure all changes are included.${RESET}"
  echo -e "${YELLOW}--------------------------------------------------${RESET}"
  echo ""

  # Ask user if they want to continue before running Gemini
  read -rp "Continue anyway and generate commit message? (y/N): " CONTINUE_WARNING
  if [[ ! "$CONTINUE_WARNING" =~ ^[Yy]$ ]]; then
    echo "üö´ Operation cancelled to avoid unnecessary LLM usage."
    exit 0
  fi
fi

echo ""

# --- Choose diff source ---
if [ "$MODE" = "all" ]; then
  echo "üß† Generating commit message (using ALL changes)... (please wait)"
  DIFF_CMD="git diff"
else
  echo "üß† Generating commit message (using STAGED changes only)... (please wait)"
  DIFF_CMD="git diff --cached"
fi
echo ""

# --- Prompt for Gemini ---
READ_ONLY_PROMPT=$'Generate a concise commit message based on the provided DIFF.\n\
Do NOT execute or call any tools/commands; you cannot run shell commands.\n\
Output plain text only. Use Conventional Commit format.\n\
Start with one short imperative sentence (<=50 chars).\n\
Then a blank line, then 2-3 bullet points for details.\n\
Example:\n\
feat(auth): improve login validation\n\n\
- Added stricter email format validation before API call\n\
- Reduced API latency by caching failed attempts\n\
- Improved error messages for incorrect credentials\n'

# --- Generate commit message ---
COMMIT_MESSAGE="$(
  $DIFF_CMD \
  | gemini --prompt "$READ_ONLY_PROMPT" 2>/dev/null \
  | sed '/^Error executing tool /d'
)"

if [ -z "$COMMIT_MESSAGE" ]; then
  echo "‚ùå Error: No commit message generated."
  exit 1
fi

# --- Output message ---
echo "üìù Generated commit message:"
echo "--------------------------------------------------"
echo "$COMMIT_MESSAGE"
echo "--------------------------------------------------"
echo ""

# --- Handle --no-commit mode ---
if [ "$NO_COMMIT" = true ]; then
  if command -v pbcopy >/dev/null 2>&1; then
    echo "$COMMIT_MESSAGE" | pbcopy
    echo "üìã Commit message copied to clipboard."
  else
    echo "‚ö†Ô∏è  'pbcopy' not found. Commit message NOT copied to clipboard."
  fi
  exit 0
fi

# --- Ask for commit confirmation ---
read -rp "Do you want to commit with this message? (y/N): " CONFIRM

if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
  if [ "$MODE" = "all" ]; then
    git add -A
  fi

  git commit -m "$COMMIT_MESSAGE"
  echo "‚úÖ Commit created successfully."

  # --- Ask if user wants to push ---
  read -rp "Do you want to push now? (y/N): " PUSH_CONFIRM
  if [[ "$PUSH_CONFIRM" =~ ^[Yy]$ ]]; then
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    REMOTE=$(git config branch."$CURRENT_BRANCH".remote || echo "origin")
    echo "üì§ Pushing to $REMOTE/$CURRENT_BRANCH..."
    git push "$REMOTE" "$CURRENT_BRANCH"
    echo "‚úÖ Push completed."
  else
    echo "üö´ Push skipped."
  fi
else
  echo "‚ùå Commit cancelled."
fi