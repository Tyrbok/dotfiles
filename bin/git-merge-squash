#!/usr/bin/env python3

import os
import subprocess
import sys
import tempfile
import importlib.util
import json

def install_local(package, local_dir):
    try:
        spec = importlib.util.find_spec(package)
        if spec is None:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package, "--target", local_dir])
        sys.path.insert(0, local_dir)
    except subprocess.CalledProcessError:
        print(f"‚ùå Failed to install {package}.")
        sys.exit(1)

temp_dir = tempfile.mkdtemp()
install_local('InquirerPy', temp_dir)
install_local('google-genai', temp_dir)

from InquirerPy import prompt
from google import genai
from google.genai import types

def get_gemini_api_key():
    """Read Gemini API key from ~/.llm_api_keys.json"""
    try:
        config_path = os.path.expanduser("~/.llm_api_keys.json")
        with open(config_path, 'r') as f:
            config = json.load(f)
        return config['providers']['gemini']['api_key']
    except Exception as e:
        print(f"Error reading API key: {e}")
        return None

def generate_commit_message_with_gemini(diff_content):
    """Generate commit message using Gemini API"""
    api_key = get_gemini_api_key()
    if not api_key:
        return None

    try:
        client = genai.Client(api_key=api_key)
        model = "gemini-2.0-flash-lite"

        prompt_text = f"""Based on this git diff, generate a concise and descriptive commit message following conventional commit format:

{diff_content}

Rules:
- Use conventional commits format: type(scope): description
- Keep it under 50 characters for the subject line
- Types: feat, fix, docs, style, refactor, test, chore
- Be specific about what changed
- Use imperative mood (e.g., "add", "fix", "update")

Generate only the commit message, nothing else."""

        contents = [
            types.Content(
                role="user",
                parts=[
                    types.Part.from_text(text=prompt_text),
                ],
            ),
        ]

        config = types.GenerateContentConfig()

        response = client.models.generate_content(
            model=model,
            contents=contents,
            config=config,
        )

        if response and response.text:
            return response.text.strip()
        else:
            return None

    except Exception as e:
        print(f"Error calling Gemini API: {e}")
        return None

def check_git_repo():
    if not os.path.isdir('.git'):
        print("Error: You are not in a Git repository.")
        sys.exit(1)

def check_git_status():
    try:
        result = subprocess.run(['git', 'status', '--porcelain'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0:
            sys.exit(1)
        if result.stdout.strip():
            print("Error: The working directory is not clean.")
            print(result.stdout)
            sys.exit(1)
    except Exception as e:
        sys.exit(1)

def get_current_branch():
    try:
        result = subprocess.run(['git', 'branch', '--show-current'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0:
            sys.exit(1)
        return result.stdout.strip()
    except Exception as e:
        sys.exit(1)

def get_local_branches():
    try:
        result = subprocess.run(['git', 'branch'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0:
            sys.exit(1)
        branches = result.stdout.splitlines()
        return [branch.strip().replace('* ', '') for branch in branches]
    except Exception as e:
        sys.exit(1)

def select_branch(branches):
    questions = [
        {
            "type": "list",
            "name": "branch",
            "message": "Select a branch:",
            "choices": branches
        }
    ]
    answers = prompt(questions)
    return answers["branch"]

def check_merge_conflicts(selected_branch):
    current_branch = get_current_branch()
    if current_branch == selected_branch:
        print(f"Error: You are already on branch {current_branch}. Please select a different branch.")
        sys.exit(1)
    try:
        result = subprocess.run(['git', 'status', '--porcelain'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0:
            sys.exit(1)
        if result.stdout.strip():
            print("Error: The working directory is not clean.")
            print(result.stdout)
            sys.exit(1)
        result = subprocess.run(['git', 'branch', '--list', selected_branch], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode != 0 or not result.stdout.strip():
            print(f"Error: Branch {selected_branch} not found.")
            sys.exit(1)
        subprocess.run(['git', 'merge', '--no-commit', '--no-ff', selected_branch], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(['git', 'merge', '--abort'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except Exception as e:
        sys.exit(1)

def get_commit_message(selected_branch):
    # Show the diff between current branch and selected branch
    current_branch = get_current_branch()
    print(f"Changes between {current_branch} and {selected_branch}:")
    print("=" * 50)

    diff_content = ""
    try:
        result = subprocess.run(['git', 'diff', current_branch, selected_branch], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode == 0:
            if result.stdout.strip():
                diff_content = result.stdout
                print(diff_content)
            else:
                print("No differences found between the branches.")
                return "chore: merge branches with no changes"
        else:
            print(f"Error getting diff: {result.stderr}")
            sys.exit(1)
    except Exception as e:
        print(f"Error executing git diff: {e}")
        sys.exit(1)

    print("=" * 50)

    # Generate commit message with Gemini
    print("ü§ñ Generating commit message with Gemini...")
    suggested_message = generate_commit_message_with_gemini(diff_content)

    if suggested_message:
        print(f"üí° Suggested commit message: {suggested_message}")

        if get_yes_no_input("Do you want to use this suggested commit message? (Y/n): "):
            return suggested_message
        else:
            print("Enter your custom commit message. End input with Ctrl+D:")
            commit_message = sys.stdin.read().strip()
            if not commit_message:
                print("Error: Commit message cannot be empty.")
                sys.exit(1)
            return commit_message
    else:
        print("‚ö†Ô∏è  Could not generate commit message with Gemini. Please enter manually.")
        print("Enter the commit message. End input with Ctrl+D:")
        commit_message = sys.stdin.read().strip()
        if not commit_message:
            print("Error: Commit message cannot be empty.")
            sys.exit(1)
        return commit_message

def get_yes_no_input(prompt_message):
    while True:
        user_input = input(prompt_message).lower()
        if user_input in ['y', 'n', 'yes', 'no', '']:
            return user_input in ['y', 'yes', '']
        print("Please respond with 'Y' or 'n'.")

def confirm_proceed():
    if not get_yes_no_input("Do you want to proceed with the merge? This action cannot be undone. (Y/n): "):
        print("Process canceled.")
        sys.exit(0)

def perform_squash_merge(selected_branch, commit_message):
    try:
        result = subprocess.run(['git', 'merge', '--squash', selected_branch], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode == 0:
            commit_result = subprocess.run(['git', 'commit', '-m', commit_message], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if commit_result.returncode == 0:
                print("üéâ Commit completed successfully.")
                return True
            else:
                print(f"‚ùóÔ∏è Error during commit: {commit_result.stderr}")
                subprocess.run(['git', 'reset', '--hard'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                sys.exit(1)
        else:
            print(f"‚ùóÔ∏è Error during squash merge: {result.stderr}")
            sys.exit(1)
    except Exception as e:
        sys.exit(1)

def check_and_push_branch(selected_branch):
    try:
        result = subprocess.run(['git', 'ls-remote', '--heads', 'origin', selected_branch], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode == 0 and result.stdout.strip():
            subprocess.run(['git', 'push', 'origin', get_current_branch()], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            print(f"üéâ Push to remote branch {selected_branch} completed successfully.")
            return True
        else:
            print(f"Remote branch for {selected_branch} not found.")
            return False
    except Exception as e:
        sys.exit(1)

def confirm_and_delete_branch(branch_name, remote=False):
    try:
        if remote:
            prompt_message = f"Do you want to delete the remote branch '{branch_name}'? (Y/n): "
            command = ['git', 'push', 'origin', '--delete', branch_name]
        else:
            prompt_message = f"Do you want to delete the local branch '{branch_name}'? (Y/n): "
            command = ['git', 'branch', '-D', branch_name]

        if get_yes_no_input(prompt_message):
            subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            print(f"üéâ {'Remote' if remote else 'Local'} branch '{branch_name}' deleted.")
        else:
            print(f"{'Remote' if remote else 'Local'} branch '{branch_name}' not deleted.")
    except Exception as e:
        sys.exit(1)

if __name__ == "__main__":
    check_git_repo()
    check_git_status()
    branches = get_local_branches()
    if not branches:
        print("No local branches found.")
        sys.exit(1)
    selected_branch = select_branch(branches)
    print(f"You have selected branch: {selected_branch}")
    check_merge_conflicts(selected_branch)
    commit_message = get_commit_message(selected_branch)
    confirm_proceed()
    if perform_squash_merge(selected_branch, commit_message):
        has_remote_branch = check_and_push_branch(selected_branch)
        confirm_and_delete_branch(selected_branch)
        if has_remote_branch:
            confirm_and_delete_branch(selected_branch, remote=True)